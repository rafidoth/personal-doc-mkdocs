{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"leetcode/leetcode349/","title":"349 Intersection of Two Arrays","text":"<p>It can be done with naive approach of two loops. For each element of  nums1 is it in the nums2 too? if yes then its an answer and for  repetitive numbers we can use <code>set</code> to get the unique values only.</p> <p>This process will take O(N^2) Time Complexity. but for the search purpose  we can use binary searching. obviously before searching in Nums2 it should be sorted. C++ sort function takes O(NlogN) time to sort a vector. </p> <pre><code>sort(nums2) // O(nlogn)\nfor each x of nums1 // O(nlogn)\n    if binarySearch(nums2, x) == true  \n        push it to the answer set\n</code></pre> <pre><code>#include&lt;bits/stdc++.h&gt; \nusing namespace std;\ntypedef long long int lli;\n#define MOD 1000000007\n\n\n\nbool binsearch(vector&lt;int&gt; arr, int target){\n    int start = 0;\n    int end = arr.size() -1 ;\n    while(start &lt;=end){\n        int mid = (start + end) /2;\n        if(arr[mid] == target) return true;\n        else if (target &gt; arr[mid]) start = mid +1;\n        else end = mid -1;\n    }\n    return false;\n}\n\n\nvector&lt;int&gt; func(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2){\n    set&lt;int&gt; ans;\n    sort(nums2.begin(),nums2.end());\n    for(int x: nums1){\n        bool found = binsearch(nums2,x) ;\n        if(found) ans.insert(x);\n    }\n    vector&lt;int&gt; v;\n    for(int a : ans)  v.push_back(a);\n    return v;\n}\n\n\n\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    vector&lt;int&gt; nums1 = {4,9,5};\n    vector&lt;int&gt; nums2 = {9,4,9,8,4};\n    vector&lt;int&gt; res = func(nums1,nums2);\n    for(int x : res ) cout &lt;&lt; x &lt;&lt; \" \";\n    cout &lt;&lt; endl;\n}\n</code></pre>"},{"location":"leetcode/leetcode410/","title":"410 Split Array Largest Sum","text":"<pre><code>#include&lt;bits/stdc++.h&gt; \nusing namespace std;\ntypedef long long int lli;\n#define MOD 1000000007\n\n\n// fun will give you the number of subarray \n// for this capacity\nint fun(vector&lt;int&gt;&amp; nums, int capacity){\n    int count = 0;\n    int sum = 0;\n    for(int x : nums){\n        if(sum+x &gt; capacity){\n            count++;\n            sum = x;\n        }else sum+=x;\n    }\n    return count+1;\n}\n\nint splitArray(vector&lt;int&gt;&amp; nums, int k){\n    int mx = nums[0];\n    for(int x: nums) if(x&gt;mx) mx= x;\n\n    int sum = 0;\n    for(int x : nums) sum+= x;\n    int start = mx;\n    int end = sum;\n    while(start&lt;=end){\n        int mid = (start + end) / 2;\n        int count = fun(nums, mid);\n        cout &lt;&lt; \"capacity: \" &lt;&lt;  mid &lt;&lt; \" | \";\n        cout &lt;&lt; \"count : \" &lt;&lt; count &lt;&lt; \" | \"&lt;&lt;endl;\n        if(count == k){\n            if(mid == mx) return mid;\n            if(fun(nums,mid-1)!= k) return mid;\n            end = mid -1;\n        }else if(count &gt; k) start = mid + 1;\n        else end = mid-1;\n    }\n\n    return start;\n}\n\nint main(){\n    #ifndef ONLINE_JUDGE\n      freopen(\"input.txt\", \"r\", stdin);\n      freopen(\"output.txt\", \"w\", stdout);\n    #endif\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    vector&lt;int&gt; nums = {1,2,3,4,5};\n    cout &lt;&lt; splitArray(nums,2) &lt;&lt; endl;\n\n}\n</code></pre>"},{"location":"leetcode/leetcode888/","title":"888 Fair Candy Swap","text":""},{"location":"leetcode/leetcode888/#naive-approach","title":"Naive Approach","text":"<p>For each element of <code>aliceSizes</code> array look into <code>bobSizes</code> and check if any one combination makes the both sum equals.</p> <p><pre><code>for each x of aliceSizes[]\n    for each y of bobSizes[]\n        if aliceSum - y + x == bobSum -x +y\n            return x and y\n</code></pre> C++ code <pre><code>vector&lt;int&gt; fairCandySwapNaive(vector&lt;int&gt;&amp; aliceSizes, vector&lt;int&gt;&amp; bobSizes) {\n    int aliceSum = 0;\n    for(int x : aliceSizes) aliceSum+= x;\n    int bobSum= 0;\n    for(int x : bobSizes) bobSum+= x;\n    vector&lt;int&gt; answer;\n\n    for (int i = 0; i &lt;(int) aliceSizes.size(); ++i) {\n        int aTemp = aliceSizes[i];\n        for (int m = 0; m &lt;(int) bobSizes.size(); ++m) {\n            int bTemp = bobSizes[m];\n            int newAliceSum = aliceSum - aTemp + bTemp;\n            int newBobSum = bobSum - bTemp + aTemp;\n            if (newAliceSum == newBobSum) {\n                answer.push_back(aTemp);\n                answer.push_back(bTemp);\n                return answer;\n            }\n        }\n    }\n    return answer;\n}\n</code></pre></p>"},{"location":"leetcode/leetcode888/#binary-search-optimization-scope","title":"Binary Search Optimization Scope","text":"<p>We need to find out the pair of numbers to exchange and make both the sum equals. In the naive approach we were trying every combinations to exchange which is time consuming and that makes the naive approach of O(n^2) Time Complexity. </p> <p>Now, the equal sum will be between their current sum and that is actually their average number by that I meant <code>newEqualSum = (aliceInitialSum + bobInitialSum)/2</code>. </p> <p>If we take an example  <code>aliceSizes = [3,4,5,9]</code> <code>aliceInitialSum = 21</code> <code>bobSizes = [7,2,6]</code> <code>bobInitialSum = 15</code> </p> <p>so for this case the new sum should be (21+15)/2 = 18 Let's see from Bob's perspective, To make the sum 18 what does Bob can do?   Bob says \"I have 7 and without 7 I have sum (15-7)=8. so if I exchange 7 I need (18-8)=10.  Alice have 10?\" Alice searched and didn't get 10 Now again,  Bob says \"I have 2 and without 2 I have sum (15-2)=13. so if I exchange 2 I need (18-13)=5.  Alice have 5?\" yes Alice got 5 and its the answer.</p> <p> So, for every element of bob we can get what's the other element which should be exchanged. and thus we can search that other element in alice's array. Here for searching  we can use binary search to take less time.  Therefore, the time complexity is O(nlogn)</p> <pre><code>for each x in bob's array\n    bobEle = x\n    aliceEle = (theirEqualSum - (bobSum - bobEle))\n    if binsearch(aliceArray, aliceEle) == true then \n        answer will be aliceEle and bobEle\n</code></pre> <p>C++ code <pre><code>vector&lt;int&gt; fairCandySwap(vector&lt;int&gt;&amp; aliceSizes, vector&lt;int&gt;&amp; bobSizes){\n\n    int asum = 0;\n    for(int x : aliceSizes) asum += x;\n    int bsum = 0;\n    for(int x : bobSizes) bsum += x;\n\n    vector&lt;int&gt; answer;\n\n    int n = bobSizes.size();\n    sort(aliceSizes.begin(), aliceSizes.end());\n    for(int i =0;i&lt;n;i++){\n        int b = bobSizes[i];\n        int target = ((asum+bsum)/2 ) - ( bsum - b);\n        bool foundTarget = binsearch(aliceSizes,target);\n        if(foundTarget){\n            answer.push_back(target);\n            answer.push_back(b);\n            return answer;\n        }\n    }\n    return answer;\n}\n</code></pre></p>"}]}